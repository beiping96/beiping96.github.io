<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Go,Performance,Json,GCTT," />








  <link rel="shortcut icon" type="image/x-icon" href="/images/B_favicon.ico?v=5.0.2" />






<meta name="description" content="Go标准库encoding&#x2F;json真的慢吗？https:&#x2F;&#x2F;medium.com&#x2F;a-journey-with-go&#x2F;go-is-the-encoding-json-package-really-slow-62b64d54b148">
<meta property="og:type" content="article">
<meta property="og:title" content="Go: Is the encoding&#x2F;json Package Really Slow?">
<meta property="og:url" content="http://blog.beiping96.com/2019/09/01/Go-Is-the-encoding-json-Package-Really-Slow/index.html">
<meta property="og:site_name" content="Beiping96&#39;s Blog">
<meta property="og:description" content="Go标准库encoding&#x2F;json真的慢吗？https:&#x2F;&#x2F;medium.com&#x2F;a-journey-with-go&#x2F;go-is-the-encoding-json-package-really-slow-62b64d54b148">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://blog.beiping96.com/images/A-Journey-With-Go.png">
<meta property="og:image" content="http://blog.beiping96.com/images/json-marshal.png">
<meta property="og:image" content="http://blog.beiping96.com/images/json-marshal-diff.png">
<meta property="og:image" content="http://blog.beiping96.com/images/json-unmarshal.png">
<meta property="article:published_time" content="2019-09-01T09:57:02.000Z">
<meta property="article:modified_time" content="2020-03-06T05:08:09.603Z">
<meta property="article:author" content="duxingrui">
<meta property="article:tag" content="Go">
<meta property="article:tag" content="Performance">
<meta property="article:tag" content="Json">
<meta property="article:tag" content="GCTT">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://blog.beiping96.com/images/A-Journey-With-Go.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="http://blog.beiping96.com/2019/09/01/Go-Is-the-encoding-json-Package-Really-Slow/"/>


  <script data-ad-client="ca-pub-7381930582570374" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <title> Go: Is the encoding/json Package Really Slow? | Beiping96's Blog </title>
<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="//schema.org/WebPage" lang="en">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Beiping96's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Go: Is the encoding/json Package Really Slow?
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2019-09-01T17:57:02+08:00" content="2019-09-01">
              2019-09-01
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2019/09/01/Go-Is-the-encoding-json-Package-Really-Slow/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/09/01/Go-Is-the-encoding-json-Package-Really-Slow/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Go标准库<code>encoding/json</code>真的慢吗？<br><a href="https://medium.com/a-journey-with-go/go-is-the-encoding-json-package-really-slow-62b64d54b148" target="_blank" rel="noopener">https://medium.com/a-journey-with-go/go-is-the-encoding-json-package-really-slow-62b64d54b148</a></p>
<a id="more"></a>
<p><img src="/images/A-Journey-With-Go.png" alt=""><br>Illustration created for “A Journey With Go”, made from the original Go Gopher, created by Renee French.<br>插图来自于“A Journey With Go”，由Go Gopher组织成员Renee French创作。</p>
<p>This article is based on Go 1.12.<br>Questions about the performance of the encoding/json package is a recurrent topic and multiple libraries like easyjson, jsoniter or ffjson are trying to address this issue. But is it really slow? Has it been improved?</p>
<p>本文基于Go 1.12。<br>关于标准库<code>encoding/json</code>性能差的问题在很多地方被讨论过，也有很多第三方库在尝试解决这个问题，比如<a href="https://github.com/mailru/easyjson" target="_blank" rel="noopener">easyjson</a>，<a href="https://github.com/json-iterator/go" target="_blank" rel="noopener">jsoniter</a>和<a href="https://github.com/pquerna/ffjson" target="_blank" rel="noopener">ffjson</a>。但是标准库<code>encoding/json</code>真的慢吗？它一直都这么慢吗？</p>
<h3 id="Evolution-of-the-package"><a href="#Evolution-of-the-package" class="headerlink" title="Evolution of the package"></a>Evolution of the package</h3><p>标准库<code>encoding/json</code>的进化之路</p>
<p>Let’s look first at the performance evolution of the library. I made a small makefile with a benchmark file in order to run it against all versions of go:<br>首先，通过一个简短的makefile文件和一段基准测试代码，我们看下在各个Go版本中，标准库<code>encoding/json</code>的性能表现。以下为基准测试代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> JSON <span class="keyword">struct</span> &#123;</span><br><span class="line">   Foo <span class="keyword">int</span></span><br><span class="line">   Bar <span class="keyword">string</span></span><br><span class="line">   Baz <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkJsonMarshall</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">   j := JSON&#123;</span><br><span class="line">      Foo: <span class="number">123</span>,</span><br><span class="line">      Bar: <span class="string">`benchmark`</span>,</span><br><span class="line">      Baz: <span class="number">123.456</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   b.ResetTimer()</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">      _, _ = json.Marshal(&amp;j)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkJsonUnmarshal</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">   bytes := <span class="string">`&#123;"foo": 1, "bar": "my string", bar: 1.123&#125;`</span></span><br><span class="line">   str := []<span class="keyword">byte</span>(bytes)</span><br><span class="line">   b.ResetTimer()</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">      j := JSON&#123;&#125;</span><br><span class="line">      _ = json.Unmarshal(str, &amp;j)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The makefile creates a folder for each version of go, creates a container based on its docker image, and runs the benchmark. The results are compared in two ways:</p>
<ul>
<li>each version VS the last version of go 1.12</li>
<li>each version VS the next version</li>
</ul>
<p>makefile文件在不同的文件夹中基于不同版本的Go创建Docker镜像，在各镜像启动的容器中运行基准测试。将从以下两个维度进行性能对比：</p>
<ul>
<li>比较Go各版本与1.12版本中标准库<code>encoding/json</code>的性能差异</li>
<li>比较Go各版本与其下一个版本中标准库<code>encoding/json</code>的性能差异</li>
</ul>
<p>The first comparison allows us to check the evolution from a specific version against the last one, while the second analysis allows us to know which one brought the most improvements into the encoding/json package.<br>第一个维度的对比可以得到在特定版本的Go与1.12版本的Go中json序列化和反序列化的性能差异；第二个维度的对比可以得到在哪次Go版本升级中json序列化和反序列化发生了最大的性能提升。</p>
<p>Here are the most significant results:<br>测试结果如下：</p>
<ul>
<li>from 1.2.0 to 1.3.0, the time for each operation has reduced by ~25/35%:</li>
<li>Go1.2至Go1.3的版本升级，序列化操作耗时减少了约28%，反序列化操作耗时减少了约35%</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name           old time/op    new time/op    delta</span><br><span class="line">JsonMarshall     1.91µs ± 2%    1.37µs ± 2%  -28.23%</span><br><span class="line">JsonUnmarshal    2.70µs ± 2%    1.75µs ± 3%  -35.18%</span><br></pre></td></tr></table></figure>

<ul>
<li>from 1.6.0 to 1.7.0, the time for each operation has reduced by ~25/40%:</li>
<li>Go1.6至Go1.7的版本升级，序列化操作耗时减少了约27%，反序列化操作耗时减少了约40%</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name             old time/op    new time/op    delta</span><br><span class="line">JsonMarshall-4     1.24µs ± 1%    0.90µs ± 2%  -27.65%</span><br><span class="line">JsonUnmarshal-4    1.52µs ± 3%    0.91µs ± 2%  -40.05%</span><br></pre></td></tr></table></figure>

<ul>
<li>from 1.10.0 to 1.11.0, the memory allocation has reduced by ~25/60%:</li>
<li>Go1.10至Go1.11的版本升级，序列化内存消耗减少了约60%，反序列化内存消耗减少了约25%</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name             old alloc/op   new alloc/op   delta</span><br><span class="line">JsonMarshall-4       208B ± 0%       80B ± 0%  -61.54%</span><br><span class="line">JsonUnmarshal-4      496B ± 0%      368B ± 0%  -25.81%</span><br></pre></td></tr></table></figure>

<ul>
<li>from 1.11.0 to 1.12.0, the time for each operation has reduced by ~5/15%:</li>
<li>Go1.11至Go1.12的版本升级，序列化操作耗时减少了约15%，反序列化操作耗时减少了约6%</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name             old time/op    new time/op    delta</span><br><span class="line">JsonMarshall-4      670ns ± 6%     569ns ± 2%  -15.09%</span><br><span class="line">JsonUnmarshal-4     800ns ± 1%     747ns ± 1%   -6.58%</span><br></pre></td></tr></table></figure>

<p>The full report is available on github for <a href="https://gist.github.com/blanchonvincent/227b6691777a1de254ce75b304a36277" target="_blank" rel="noopener">Marshall and Unmarshall</a>.<br>可以在这里看到完整的<a href="https://gist.github.com/blanchonvincent/227b6691777a1de254ce75b304a36277" target="_blank" rel="noopener">测试结果</a>。</p>
<p>If we check from 1.2.0 to 1.12.0, the performances have significantly improved:<br>如果对比Go1.2与Go1.12，会发现标准库<code>encoding/json</code>的性能有显著提高，操作耗时减少了约69%/68%，内存消耗减少了约74%/29%：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name           old time/op    new time/op    delta</span><br><span class="line">JsonMarshall     1.72µs ± 2%    0.52µs ± 2%  -69.68%</span><br><span class="line">JsonUnmarshal    2.72µs ± 2%    0.85µs ± 5%  -68.70%</span><br><span class="line"></span><br><span class="line">name           old alloc/op   new alloc/op   delta</span><br><span class="line">JsonMarshall       188B ± 0%       48B ± 0%  -74.47%</span><br><span class="line">JsonUnmarshal      519B ± 0%      368B ± 0%  -29.09%</span><br></pre></td></tr></table></figure>

<p>The benchmark has been done with a simple struct. The deltas could be different with a different value to encode/decode things such as a map or an array or even a bigger struct.<br>该基准测试使用了较为简单的json结构。使用更加复杂的结构（例如：Map or Array）进行测试会导致各版本之间性能增幅与本文不同。</p>
<h3 id="Dive-into-the-code"><a href="#Dive-into-the-code" class="headerlink" title="Dive into the code"></a>Dive into the code</h3><p>速读源码</p>
<p>The best way to understand why it seems slower is to dive into the code. Here is the flow of the Marshal method in go 1.12:<br>想了解标准库性能较差的原因的最好的办法就是读源码，以下为Go1.12版本中<code>json.Marshal</code>函数的执行流程：</p>
<p><img src="/images/json-marshal.png" alt=""></p>
<p>Now that we know the flow, let’s compare the code of the versions 1.10 and 1.12 since we have seen there was a huge improvement on the memory during the Marshal process. The first modification that we see is related to the first step of the flow when the encoder is retrieved from the cache:<br>在了解了<code>json.Marshal</code>函数的执行流程后，再来比较下在Go1.10和Go1.12版本中的<code>json.Marshal</code>函数在实现上有什么变化。通过之前的测试，可以发现从Go1.10至Go1.12版本中的<code>json.Marshal</code>函数的内存消耗上有了很大的改善。从源码的变化中可以发现在Go1.12版本中的<code>json.Marshal</code>函数添加了encoder（编码器）的内存缓存：</p>
<p><img src="/images/json-marshal-diff.png" alt=""></p>
<p>The sync.Pool has been added here in order to share the encoder and reduce the number of allocations. The method newEncodeState() <a href="https://github.com/golang/go/commit/c0547476f342665514904cf2581a62135d2366c3#diff-e79d4db81e8544657cb631be813f89b4" target="_blank" rel="noopener">already existed</a> in 1.10 but was not used. To confirm that, we can just replace this piece of code in go 1.10 and check the new result:<br>在使用了<code>sync.Pool</code>缓存encoder后，<code>json.Marshal</code>函数极大地减少了内存分配操作。实际上<code>newEncodeState()</code>函数在Go1.10版本中就<a href="https://github.com/golang/go/commit/c0547476f342665514904cf2581a62135d2366c3#diff-e79d4db81e8544657cb631be813f89b4" target="_blank" rel="noopener">已经存在了</a>，只不过没有被使用。为验证是添加了内存缓存带来了性能提升的猜想，可以在Go1.10版本中修改<code>json.Marshal</code>函数后，再进行测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name           old alloc/op   new alloc/op   delta</span><br><span class="line">CodeMarshal-4    4.59MB ± 0%    1.98MB ± 0%  -56.92%</span><br></pre></td></tr></table></figure>

<p>In order to run the benchmark with the <a href="https://github.com/golang/go" target="_blank" rel="noopener">Go repository</a>, just go to the folder of the lib and run:<br>可以直接在<a href="https://github.com/golang/go" target="_blank" rel="noopener">Go源码</a>中，执行以下命令进行基准测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> encoding/json -bench=BenchmarkCodeMarshal -benchmem -count=10 -run=^$</span><br></pre></td></tr></table></figure>

<p>As we can see, the impact of the <a href="https://golang.org/pkg/sync/" target="_blank" rel="noopener">sync package</a> is huge and should be considered in your project when you allocate the same struct intensively.<br>结果和我们的猜想是一致的。是<a href="https://golang.org/pkg/sync/" target="_blank" rel="noopener">sync包</a>给<code>json.Marshal</code>函数带来了性能提升。同样也给我们带来一点启发，当项目也有这种对同一个结构体进行大量的内存分配时，也可以通过添加内存缓存的方式提升性能。</p>
<p>Regarding the the Unmarshal method, here is the flow in go 1.12:<br>以下为Go1.12版本中，<code>json.Unmarshal</code>函数的执行流程：</p>
<p><img src="/images/json-unmarshal.png" alt=""></p>
<p>Each of the flows are pretty optimized with a cache strategy — thanks to sync package — and we can see that the part regarding the reflection and the iteration on each fields is the bottleneck of the package.<br><code>json.Unmarshal</code>函数同样使用<code>sync.Pool</code>缓存了decoder。<br>对于json序列化和反序列化而言，其性能瓶颈是迭代、反射json结构中每个字段。</p>
<h3 id="Alternatives-and-performances"><a href="#Alternatives-and-performances" class="headerlink" title="Alternatives and performances"></a>Alternatives and performances</h3><p>与第三方库的性能对比</p>
<p>There are many alternatives in the Go community. <a href="https://github.com/pquerna/ffjson" target="_blank" rel="noopener">ffjson</a>, that is one of them, generates static MarshalJSON and UnmarshalJSON functions that are called from a similar API: <code>ffjson.Marshaland</code> <code>ffjson.Unmarshal</code>. The generated methods look like this:<br>GitHub上也有很多用于json序列化的第三方库，比如<a href="https://github.com/pquerna/ffjson" target="_blank" rel="noopener">ffjson</a>就是其中之一，ffjson的命令行工具可以为指定的结构生成静态的MarshalJSON和UnmarshalJSON函数，MarshalJSON和UnmarshalJSON函数在序列化和反序列化操作时会分别被<code>ffjson.Marshal</code>和<code>ffjson.Unmarshal</code>函数调用。以下为ffjson生成的解析器示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(j *JSONFF)</span> <span class="title">MarshalJSON</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> buf fflib.Buffer</span><br><span class="line">   <span class="keyword">if</span> j == <span class="literal">nil</span> &#123;</span><br><span class="line">      buf.WriteString(<span class="string">"null"</span>)</span><br><span class="line">      <span class="keyword">return</span> buf.Bytes(), <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line">   err := j.MarshalJSONBuf(&amp;buf)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> buf.Bytes(), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MarshalJSONBuf marshal buff to json - template</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(j *JSONFF)</span> <span class="title">MarshalJSONBuf</span><span class="params">(buf fflib.EncodingBuffer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> j == <span class="literal">nil</span> &#123;</span><br><span class="line">      buf.WriteString(<span class="string">"null"</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> err error</span><br><span class="line">   <span class="keyword">var</span> obj []<span class="keyword">byte</span></span><br><span class="line">   _ = obj</span><br><span class="line">   _ = err</span><br><span class="line">   buf.WriteString(<span class="string">`&#123;"Foo":`</span>)</span><br><span class="line">   fflib.FormatBits2(buf, <span class="keyword">uint64</span>(j.Foo), <span class="number">10</span>, j.Foo &lt; <span class="number">0</span>)</span><br><span class="line">   buf.WriteString(<span class="string">`,"Bar":`</span>)</span><br><span class="line">   fflib.WriteJsonString(buf, <span class="keyword">string</span>(j.Bar))</span><br><span class="line">   buf.WriteString(<span class="string">`,"Baz":`</span>)</span><br><span class="line">   fflib.AppendFloat(buf, <span class="keyword">float64</span>(j.Baz), <span class="string">'g'</span>, <span class="number">-1</span>, <span class="number">64</span>)</span><br><span class="line">   buf.WriteByte(<span class="string">'&#125;'</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Let’s now compare the benchmark between the standard library and ffjson (with usage of ffjson.Pool()):<br>现在比较一下标准库和ffjson（使用了<code>ffjson.Pool()</code>）的性能差异：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">standard lib:</span><br><span class="line">name             time/op</span><br><span class="line">JsonMarshall-4   500ns ± 2%</span><br><span class="line">JsonUnmarshal-4  677ns ± 2%</span><br><span class="line"></span><br><span class="line">name             alloc/op</span><br><span class="line">JsonMarshall-4   48.0B ± 0%</span><br><span class="line">JsonUnmarshal-4   320B ± 0%</span><br><span class="line"></span><br><span class="line">ffjson:</span><br><span class="line">name               time/op</span><br><span class="line">JsonMarshallFF-4   538ns ± 1%</span><br><span class="line">JsonUnmarshalFF-4  827ns ± 3%</span><br><span class="line"></span><br><span class="line">name               alloc/op</span><br><span class="line">JsonMarshallFF-4    176B ± 0%</span><br><span class="line">JsonUnmarshalFF-4   448B ± 0%</span><br></pre></td></tr></table></figure>

<p>For Marshaling or Unmarshaling, it looks like that the native library is more efficient.<br>对于json序列化/反序列化，标准库与ffjson相比反而更加高效一些。</p>
<p>Regarding the higher usage of memory, we can see with the compiler <code>go run -gcflags=&quot;-m&quot;</code> some variables will be allocated to the heap:<br>对于内存使用情况（堆分配），可以通过<code>go run -gcflags=&quot;-m&quot;</code>命令进行测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:46:19: buf escapes to heap</span><br><span class="line">:48:23: buf escapes to heap</span><br><span class="line">:27:26: &amp;buf escapes to heap</span><br><span class="line">:22:6: moved to heap: buf</span><br></pre></td></tr></table></figure>

<p>Let’s have a look at another one: <a href="https://github.com/mailru/easyjson" target="_blank" rel="noopener">easyjson</a>. It uses the same strategy. Here is the benchmark:<br><a href="https://github.com/mailru/easyjson" target="_blank" rel="noopener">easyjson</a>库也使用了和ffjson同样的策略，以下为基准测试结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">standard lib:</span><br><span class="line">name             time/op</span><br><span class="line">JsonMarshall-4   500ns ± 2%</span><br><span class="line">JsonUnmarshal-4  677ns ± 2%</span><br><span class="line"></span><br><span class="line">name             alloc/op</span><br><span class="line">JsonMarshall-4   48.0B ± 0%</span><br><span class="line">JsonUnmarshal-4   320B ± 0%</span><br><span class="line"></span><br><span class="line">easyjson:</span><br><span class="line">name               time/op</span><br><span class="line">JsonMarshallEJ-4   349ns ± 1%</span><br><span class="line">JsonUnmarshalEJ-4  341ns ± 5%</span><br><span class="line"></span><br><span class="line">name               alloc/op</span><br><span class="line">JsonMarshallEJ-4    240B ± 0%</span><br><span class="line">JsonUnmarshalEJ-4   256B ± 0%</span><br></pre></td></tr></table></figure>

<p>This time, it seems than easyjson is much faster, 30% for the Marshalling and almost 2 times faster for the Unmarshalling. Everything make sense if we look at the <code>easyjson.Marshal</code> method provided by the library:<br>这次，easyjson比标准库更高效些，对于json序列化有30%的性能提升，对于json反序列化性能提升接近2倍。通过阅读<code>easyjson.Marshal</code>的源码，可以发现它高效的原因：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Marshal</span><span class="params">(v Marshaler)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">   w := jwriter.Writer&#123;&#125;</span><br><span class="line">   v.MarshalEasyJSON(&amp;w)</span><br><span class="line">   <span class="keyword">return</span> w.BuildBytes()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The method <code>MarshalEasyJSON</code> is generated by the library in order to print the JSON:<br>通过easyjson的命令行工具生成的编码器<code>MarshalEasyJSON</code>方法可用于json序列化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">easyjson42239ddeEncode</span><span class="params">(out *jwriter.Writer, in JSON)</span></span> &#123;</span><br><span class="line">   out.RawByte(<span class="string">'&#123;'</span>)</span><br><span class="line">   first := <span class="literal">true</span></span><br><span class="line">   _ = first</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">const</span> prefix <span class="keyword">string</span> = <span class="string">",\"Foo\":"</span></span><br><span class="line">      <span class="keyword">if</span> first &#123;</span><br><span class="line">         first = <span class="literal">false</span></span><br><span class="line">         out.RawString(prefix[<span class="number">1</span>:])</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         out.RawString(prefix)</span><br><span class="line">      &#125;</span><br><span class="line">      out.Int(<span class="keyword">int</span>(in.Foo))</span><br><span class="line">   &#125;</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">const</span> prefix <span class="keyword">string</span> = <span class="string">",\"Bar\":"</span></span><br><span class="line">      <span class="keyword">if</span> first &#123;</span><br><span class="line">         first = <span class="literal">false</span></span><br><span class="line">         out.RawString(prefix[<span class="number">1</span>:])</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         out.RawString(prefix)</span><br><span class="line">      &#125;</span><br><span class="line">      out.String(<span class="keyword">string</span>(in.Bar))</span><br><span class="line">   &#125;</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">const</span> prefix <span class="keyword">string</span> = <span class="string">",\"Baz\":"</span></span><br><span class="line">      <span class="keyword">if</span> first &#123;</span><br><span class="line">         first = <span class="literal">false</span></span><br><span class="line">         out.RawString(prefix[<span class="number">1</span>:])</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         out.RawString(prefix)</span><br><span class="line">      &#125;</span><br><span class="line">      out.Float64(<span class="keyword">float64</span>(in.Baz))</span><br><span class="line">   &#125;</span><br><span class="line">   out.RawByte(<span class="string">'&#125;'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v JSON)</span> <span class="title">MarshalEasyJSON</span><span class="params">(w *jwriter.Writer)</span></span> &#123;</span><br><span class="line">   easyjson42239ddeEncode(w, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>As we can see, there is no more reflection. The flow is pretty straightforward. Also, the library provide compatibility with the native JSON library:<br>正如我们所见，这里没有使用反射。整体流程也很简单。而且，easyjson也可以兼容标准库：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v JSON)</span> <span class="title">MarshalJSON</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">   w := jwriter.Writer&#123;&#125;</span><br><span class="line">   easyjson42239ddeEncodeGithubComMyCRMTeamEncodingJsonEasyjson(&amp;w, v)</span><br><span class="line">   <span class="keyword">return</span> w.Buffer.BuildBytes(), w.Error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>However, the performances here will be worse than the native library since the native flow will be applied and only this small part of code will be run during the Marshalling.<br>然而，使用这种兼容标准库的方式进行序列化会比直接使用标准库性能更差，因为在进行json序列化的过程中，标准库依然会通过反射构造encoder，且<code>MarshalJSON</code>中这一段代码也会被执行。</p>
<h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>结论</p>
<p>If many efforts have been done on the standard library, it could be never be as fast as a library that dumps the generation of the JSON. The negative points here are that you will have to maintain this code generation and remain dependent on an external library.</p>
<p>Prior to making any decision about switching from the standard library, you should measure how the json Marshalling/Unmarshalling impacts your application and if a gain of performance could drastically improve the performance of your whole application. If it represents only a small percentage, it is maybe not worth it, the standard library is now efficient enough in most of the cases.</p>
<p>无论在标准库上做多少努力，它都不会比通过<strong>对明确的json结构生成encoder/decoder</strong>的方式性能好。而通过结构生成解析器代码的方式需要生成和维护此代码，并且依赖于外部的库。</p>
<p>在做出使用第三方序列化库替换标准库的决定前，最好先测试下json序列化和反序列化是否是应用的性能瓶颈点，提高json序列化的效率是否能改善应用的性能。如果json序列化和反序列化并不是应用的性能瓶颈点，为了极少的性能提升，付出第三方库的维护成本是不值得的。毕竟，在大多数业务场景下，Go的标准库<code>encoding/json</code>已经足够高效了。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Go/" rel="tag">#Go</a>
          
            <a href="/tags/Performance/" rel="tag">#Performance</a>
          
            <a href="/tags/Json/" rel="tag">#Json</a>
          
            <a href="/tags/GCTT/" rel="tag">#GCTT</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/11/01/Go-Type/" rel="next" title="Go Type">
                <i class="fa fa-chevron-left"></i> Go Type
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/10/09/Controlling-the-go-runtime/" rel="prev" title="Controlling the Go Runtime">
                Controlling the Go Runtime <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>

          <!-- ad start -->
          <script data-ad-client="ca-pub-7381930582570374" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
          <!-- ad end -->

          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript" target="_blank" rel="noopener">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/beiping96.png"
               alt="duxingrui" />
          <p class="site-author-name" itemprop="name">duxingrui</p>
          <p class="site-description motion-element" itemprop="description">beiping96@gmail.com</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">46</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">30</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Evolution-of-the-package"><span class="nav-number">1.</span> <span class="nav-text">Evolution of the package</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dive-into-the-code"><span class="nav-number">2.</span> <span class="nav-text">Dive into the code</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Alternatives-and-performances"><span class="nav-number">3.</span> <span class="nav-text">Alternatives and performances</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Conclusion"><span class="nav-number">4.</span> <span class="nav-text">Conclusion</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" style="text-align:center">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <span id="busuanzi_container_site_pv">Total <span id="busuanzi_value_site_pv"></span> views,</span>
  <span id="busuanzi_container_page_pv">this page <span id="busuanzi_value_page_pv"></span> hits.</span>
  <br/>
  
  &copy;
   2016
   - 
  
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love"><i class="fa fa-heart"></i></span>
  <span class="author" itemprop="copyrightHolder"><a href="mailto:beiping96@gmail.com">duxingrui</a></span>

  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-98210842-1', 'auto');
  ga('send', 'pageview');
  </script>

</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'http-blog-beiping96-com';
      var disqus_identifier = '2019/09/01/Go-Is-the-encoding-json-Package-Really-Slow/';
      var disqus_title = "Go: Is the encoding/json Package Really Slow?";
      var disqus_url = 'http://blog.beiping96.com/2019/09/01/Go-Is-the-encoding-json-Package-Really-Slow/';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
        var disqus_config = function () {
            this.page.url = disqus_url;
            this.page.identifier = disqus_identifier;
            this.page.title = disqus_title;
        };
        run_disqus_script('embed.js');
      
    </script>
  




  
  

  

  

  

  


<!--
  <script type="text/javascript" color="0,0,0" opacity='0.33' zIndex="-1" count="66" src="/js/src/canvas-nest.min.js"></script>
-->

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/Epsilon2.1.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>
