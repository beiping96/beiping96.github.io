<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Go,Effective Go," />








  <link rel="shortcut icon" type="image/x-icon" href="/images/B_favicon.ico?v=5.0.2" />






<meta name="description" content="Parts of Effective Go">
<meta property="og:type" content="article">
<meta property="og:title" content="EffectiveGo-4-方法、接口和其它类型">
<meta property="og:url" content="http://blog.beiping96.com/2016/12/16/EffectiveGo-4-%E6%96%B9%E6%B3%95%E3%80%81%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E5%AE%83%E7%B1%BB%E5%9E%8B/index.html">
<meta property="og:site_name" content="Beiping96&#39;s Blog">
<meta property="og:description" content="Parts of Effective Go">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2016-12-16T12:33:53.000Z">
<meta property="article:modified_time" content="2020-03-06T05:08:09.601Z">
<meta property="article:author" content="duxingrui">
<meta property="article:tag" content="Go">
<meta property="article:tag" content="Effective Go">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="http://blog.beiping96.com/2016/12/16/EffectiveGo-4-方法、接口和其它类型/"/>


  <script data-ad-client="ca-pub-7381930582570374" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <title> EffectiveGo-4-方法、接口和其它类型 | Beiping96's Blog </title>
<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="//schema.org/WebPage" lang="en">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Beiping96's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                EffectiveGo-4-方法、接口和其它类型
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-12-16T20:33:53+08:00" content="2016-12-16">
              2016-12-16
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/12/16/EffectiveGo-4-%E6%96%B9%E6%B3%95%E3%80%81%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E5%AE%83%E7%B1%BB%E5%9E%8B/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/12/16/EffectiveGo-4-方法、接口和其它类型/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Parts of <code>Effective Go</code></p>
<a id="more"></a>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="指针和值-Pointers-vs-Values"><a href="#指针和值-Pointers-vs-Values" class="headerlink" title="指针和值 Pointers vs Values"></a>指针和值 <code>Pointers vs Values</code></h4><p>可以为任何已命名的类型（除了指针和接口）定义方法<br>接收者可以不是结构体</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ByteSlice []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Append 是类型ByteSlice 的方法</span></span><br><span class="line"><span class="comment">// 方法Append 的接收者slice 的类型是 ByteSlice</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(slice ByteSlice)</span> <span class="title">Append</span><span class="params">(data []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	<span class="comment">// TODO xx</span></span><br><span class="line">	<span class="comment">// return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果需要该方法可更新接收者</span></span><br><span class="line"><span class="comment">// 可以将接收者改为指向 ByteSlice类型数值的指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ByteSlice)</span> <span class="title">Append</span><span class="params">(data []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">	slice := *p</span><br><span class="line">	<span class="comment">// TODO xx</span></span><br><span class="line">	*p = slice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为类型*ByteSlice 构建与标准Write方法</span></span><br><span class="line"><span class="comment">// 类型*ByteSlice 满足了标准io.Writer接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ByteSlice)</span> <span class="title">Write</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">	slice := *p</span><br><span class="line">	<span class="comment">// TODO xx</span></span><br><span class="line">	*p = slice</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(data), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b ByteSlice</span><br><span class="line">fmt.Fprintf(&amp;b, <span class="string">"This hour has %d days\n"</span>, <span class="number">7</span>)</span><br><span class="line"><span class="comment">// 只有 *ByteSlice (指针类型) 才满足 io.Writer</span></span><br></pre></td></tr></table></figure>

<p>以指针或值为接收者的区别在于：</p>
<ul>
<li>指针方法 可以修改接收者</li>
<li>值方法 会导致方法接收到的是该值的副本，任何修改都无意义</li>
</ul>
<p>如果该值是可寻址的，当使用值调用指针方法时，<code>Go</code>语言会自动插入取址符<br>编译器会将<code>b.Write</code>重写为<code>(&amp;b).Write</code></p>
<p><strong>在字节切片上使用<code>io.Writer</code>接口已被<code>bytes.Buffer</code>实现</strong></p>
<h3 id="接口和其它类型-Interfaces-and-other-types"><a href="#接口和其它类型-Interfaces-and-other-types" class="headerlink" title="接口和其它类型 Interfaces and other types"></a>接口和其它类型 <code>Interfaces and other types</code></h3><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p><code>Go</code>中的接口为指定的对象的行为提供了一种方法<br><code>If something can do this, then it can be used here.</code></p>
<ul>
<li>通过实现<code>String</code>方法，从而实现<code>fmt.Stringer</code>接口，可以自定义打印函数</li>
<li>通过实现<code>Write</code>方法，从而实现<code>io.Writer</code>接口，可以被<code>fmt.Fprintf</code>写入</li>
</ul>
<p>在<code>Go</code>中，仅包含一两种方法的接口很常见，且其名称通常来自于实现它的方法<br><code>Such as io.Writer for something that implements Write.</code></p>
<p>每种类型都能实现多个接口<br>例如实现了<code>sort.Interface</code>接口的集合就可通过<code>sort</code>包中的函数进行排序，该接口包括<code>Len()</code>、<code>Less(i, j int) bool</code>、<code>Swap(i, j int)</code>方法，且该集合仍然可以实现<code>fmt.Stringer</code>接口</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Sequence []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Methods required by sort.Interface.</span></span><br><span class="line"><span class="comment">// 实现 sort.Interface 必需的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Sequence)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Sequence)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s[i] &lt; s[j]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Sequence)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	s[i], s[j] = s[j], s[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于打印的方法</span></span><br><span class="line"><span class="comment">// 在打印前对元素进行排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Sequence)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	sort.Sort(s)</span><br><span class="line">	str := <span class="string">"["</span></span><br><span class="line">	<span class="keyword">for</span> i, elem := <span class="keyword">range</span> s &#123;</span><br><span class="line">		<span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">			str += <span class="string">" "</span></span><br><span class="line">		&#125;</span><br><span class="line">		str += fmt.Sprint(elem)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> str + <span class="string">"]"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类型转换-Conversions"><a href="#类型转换-Conversions" class="headerlink" title="类型转换 Conversions"></a>类型转换 <code>Conversions</code></h4><p><code>Sequence</code>的<code>String</code>方法重新实现了切片的<code>String</code>方法<br>若在调用<code>fmt.Sprint</code>之前将<code>Sequence</code>转换为纯粹的<code>[]int</code>，就能使用切片默认实现的<code>String</code>方法<br>如果不进行类型转换的话，<code>fmt.Sprint</code>会执行<code>Sequence.String</code>方法，<code>Sequence.String</code>方法又会执行<code>fmt.Sprint</code>，溢栈。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过类型转换实现在String方法中安全调用Sprint</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Sequence)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	sort.Sort(s)</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprint([]<span class="keyword">int</span>(s))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 忽略类型名的情况下</span></span><br><span class="line"><span class="comment">// 类型Sequence 和 类型[]int 是相同的</span></span><br><span class="line"><span class="comment">// 因此二者之间进行的转换也是合法的</span></span><br></pre></td></tr></table></figure>
<p>上述类型转换过程并不会创建新值，它只是让现有的值看起来有个新类型而已<br>而有些合法的转换会创建新值，例如从整数转换为浮点数等</p>
<p>在<code>Go</code>中，为了访问不同的方法集合，而进行类型转换的情况是非常常见的</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 sort.intSilce 来简化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Sequence)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	sort.IntSlice(s).Sort()</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprint([]<span class="keyword">int</span>(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不必让<code>Sequence</code>实现多个接口（排序和打印），可以通过将数据转换为多种类型（<code>Sequence</code>、<code>sort.IntSlice</code>和<code>[]int</code>）来使用相应的功能，这种方法往往很有效。</p>
<h4 id="接口转换"><a href="#接口转换" class="headerlink" title="接口转换"></a>接口转换</h4><p>类型选择(<code>Type switch</code>)是类型转换的一种形式，它接受一个接口，在<code>switch</code>中依据类型选择对应的<code>case</code>，并在某种意义上将其转换为该种类型</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fmt.Printf 类型选择简化版</span></span><br><span class="line"><span class="comment">// 将值转换为字符串</span></span><br><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">	String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Value provided by caller.</span></span><br><span class="line"><span class="comment">// 调用者提供 Value</span></span><br><span class="line"><span class="keyword">var</span> value <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">switch</span> str := Value.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">string</span>: <span class="comment">// 获取具体的值</span></span><br><span class="line">	<span class="keyword">return</span> str</span><br><span class="line"><span class="keyword">case</span> Stringer: <span class="comment">// 将该接口转换为另一个接口</span></span><br><span class="line">	<span class="keyword">return</span> str.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当明确知道一个值的类型，使用类型断言就可以提取它<br>当类型选择只有一种情况（只会进入某个<code>case</code>）时，使用类型断言就可以了<br>类型断言只接受一个接口值，并从中提取明确类型的值<br>格式<code>value.(typeName)</code><br>提取字符串<code>str := value.(string)</code>，如果它所转换的值中不包含字符串，该语句就会以运行时错误崩溃<br>可使用<code>comma, ok</code>语句安全的判断该值是否是字符串</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若类型断言失败</span></span><br><span class="line"><span class="comment">// str将继续存在</span></span><br><span class="line"><span class="comment">// str将拥有字符串类型的零值-空字符串</span></span><br><span class="line">str, ok := value.(<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"string value is: %q\n"</span>, str)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"value is not a string\n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> str, ok := value.(<span class="keyword">string</span>); ok &#123;</span><br><span class="line">	<span class="keyword">return</span> str</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> str, ok := value.(Stringer); ok &#123;</span><br><span class="line">	<span class="keyword">return</span> str.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若某种现有的类型仅仅实现了一个接口，且除此之外并没有可导出的方法，则该类型本身就无需导出<br>仅导出该接口能让调用者更专注于其行为而非实现，其它不同属性的实现能反映出该原始类型的行为<br>同样也能够避免为每个通用接口的实例重复编写文档</p>
<p>构造函数应当返回一个接口值而非实现的类型<br>例如在<code>hash</code>库中，<code>crc32.NewIEEE</code>和<code>adler32.New</code>都返回接口类型<code>hash.Hash32</code>，如果要使用<code>Adler32算法</code>替换<code>CRC-32</code>，只需修改构造函数调用即可， 其余代码则不受算法改变的影响<br>同样的方式能将<code>crypto</code>包中多种联系在一起的流密码算法与块密码算法分开，<code>crypto/cipher</code>包中的<code>Block</code>接口指定了块密码算法的行为，它为单独的数据块提供加密，和<code>bufio</code>包类型，任何实现了该接口的密码包都能被用于构造以<code>Stream</code>为接口表示的流密码，而无需知道块密码的细节</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Block <span class="keyword">interface</span> &#123;</span><br><span class="line">	BlockSize() <span class="keyword">int</span></span><br><span class="line">	Encrypt(src, dst []<span class="keyword">byte</span>)</span><br><span class="line">	Decrypt(src, dst []<span class="keyword">byte</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Stream <span class="keyword">interface</span> &#123;</span><br><span class="line">	XORKeyStream(dst, src []<span class="keyword">byte</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计数器模式CTR流定义</span></span><br><span class="line"><span class="comment">// 它将块加密改为流加密</span></span><br><span class="line"><span class="comment">// 块加密细节已被抽象化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NewCTR 返回一个 Stream</span></span><br><span class="line"><span class="comment">// 其加密/解密使用计数器模式中给定的 Block 进行</span></span><br><span class="line"><span class="comment">// iv 的长度必须与 Block 的块大小相同</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCTR</span><span class="params">(block Block, iv []<span class="keyword">byte</span>)</span> <span class="title">Stream</span></span> &#123;</span><br><span class="line">	<span class="comment">// TODO xx</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>NewCTR</code>的应用并不仅限于特定的加密算法和数据源，它适用于任何对<code>Block</code>接口和<code>Stream</code>的实现<br>因为它们返回接口值，所以用其它加密模式来代替<code>CTR</code>只需做局部的更改<br>构造函数的调用过程必须被修改，但由于其周围的代码只将它看做<code>Stream</code>，因此它们不会注意到其中的区别</p>
<h4 id="接口和方法"><a href="#接口和方法" class="headerlink" title="接口和方法"></a>接口和方法</h4><p>因为几乎任何类型都能添加方法，所以几乎任何类型都能满足一个接口</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http 包中定义了 Handler 接口</span></span><br><span class="line"><span class="comment">// 任何实现了 Handler 的对象都能处理 HTTP 请求</span></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">	ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ResponseWriter</code>接口提供了对响应客户端请求的方法的访问<br>由于这些方法包含了标准的<code>Write</code>方法，因此<code>http.ResponseWriter</code>可用于任何<code>io.Writer</code>适用的场景<br><code>Request</code>结构体包含已解析的客户端请求</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设所有的 HTTP 请求都是 GET</span></span><br><span class="line"><span class="comment">// 忽略 POST</span></span><br><span class="line"><span class="comment">// 以下代码用于记录某个页面被访问的次数</span></span><br><span class="line"><span class="keyword">type</span> Counter <span class="keyword">struct</span> &#123;</span><br><span class="line">	n <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ctr *Counter)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">	ctr.n++</span><br><span class="line">	fmt.Fprintf(w, <span class="string">"counter = %d\n"</span>, ctr.n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将一个服务器添加到 URL 树的一个节点上</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"><span class="comment">// TODO xx</span></span><br><span class="line">ctr := <span class="built_in">new</span>(Counter)</span><br><span class="line">http.Handle(<span class="string">"/counter"</span>, ctr)</span><br></pre></td></tr></table></figure>
<p><code>Counter</code>不一定要是结构体，也可以是整数<code>type Counter int</code><br>但是接收者必须是<code>指针类型</code>，增量操作对于调用者才是可见的</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当页面被访问时</span></span><br><span class="line"><span class="comment">// 使用信道去通知程序更新内部状态</span></span><br><span class="line"><span class="comment">// 每次浏览该信道都会发送一个提醒</span></span><br><span class="line"><span class="keyword">type</span> Chan <span class="keyword">chan</span> *http.Request</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ch Chan)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">	ch &lt;- req</span><br><span class="line">	fmt.Fprint(w, <span class="string">"notification sent"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出调用服务器二进制程序时使用的实参 /args</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ArgServer</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(os.Args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为函数写一个方法</span></span><br><span class="line"><span class="comment">// HandlerFunc 类型是一个适配器</span></span><br><span class="line"><span class="comment">// 它允许将普通函数用做 HTTP 处理程序</span></span><br><span class="line"><span class="comment">// 若 f 是具有适当签名的函数</span></span><br><span class="line"><span class="comment">// HandlerFunc(f) 就是调用 f 的处理程序对象</span></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f HandlerFunc)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, req *Request)</span></span> &#123;</span><br><span class="line">	f(w, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>HandlerFunc</code>是具有<code>ServeHTTP</code>方法的类型，因此该类型的值就能处理<code>HTTP</code>请求<br>接收者是一个函数<code>f</code>，而该方法调用<code>f</code><br>接收者变成了一个信道，而方法通过该信道发送消息</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 让 ArgServer 拥有合适的签名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ArgServer</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">	fmt.Fprintln(w, os.Args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ArgServer 和 HandlerFunc 拥有了相同的签名</span></span><br><span class="line"><span class="comment">// 现在可以将其转换为这种类型以访问它的方法</span></span><br><span class="line">http.Handle(<span class="string">"/args"</span>, http.HandlerFunc(ArgServer))</span><br></pre></td></tr></table></figure>
<p>当<code>/args</code>页面被访问时，绑定到该页面的处理程序就有了<code>值ArgServer</code>和<code>类型HandlerFunc</code><br><code>HTTP</code>服务器会以<code>ArgServer</code>为接收者，调用该类型的<code>ServeHTTP</code>方法<br><code>ServeHTTP</code>方法会反过来调用<code>ArgServer</code>(通过<code>f(c, req)</code>)，实参就会被显示出来</p>
<p><strong>接口只是方法的集合，而几乎任何类型都能定义方法。</strong><br><code>Interfaces are just sets of methods, which can be defined for (almost) any type.</code></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Go/" rel="tag">#Go</a>
          
            <a href="/tags/Effective-Go/" rel="tag">#Effective Go</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/12/09/EffectiveGo-3-%E6%95%B0%E6%8D%AE%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96/" rel="next" title="EffectiveGo-3-数据、初始化">
                <i class="fa fa-chevron-left"></i> EffectiveGo-3-数据、初始化
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/12/23/EffectiveGo-5-%E7%A9%BA%E7%99%BD%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%86%85%E5%B5%8C/" rel="prev" title="EffectiveGo-5-空白标识符、内嵌">
                EffectiveGo-5-空白标识符、内嵌 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>

          <!-- ad start -->
          <script data-ad-client="ca-pub-7381930582570374" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
          <!-- ad end -->

          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript" target="_blank" rel="noopener">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/wlw.png"
               alt="duxingrui" />
          <p class="site-author-name" itemprop="name">duxingrui</p>
          <p class="site-description motion-element" itemprop="description">beiping96@gmail.com</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">47</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">31</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法"><span class="nav-number">1.</span> <span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#指针和值-Pointers-vs-Values"><span class="nav-number">1.1.</span> <span class="nav-text">指针和值 Pointers vs Values</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接口和其它类型-Interfaces-and-other-types"><span class="nav-number">2.</span> <span class="nav-text">接口和其它类型 Interfaces and other types</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#接口"><span class="nav-number">2.1.</span> <span class="nav-text">接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类型转换-Conversions"><span class="nav-number">2.2.</span> <span class="nav-text">类型转换 Conversions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接口转换"><span class="nav-number">2.3.</span> <span class="nav-text">接口转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接口和方法"><span class="nav-number">2.4.</span> <span class="nav-text">接口和方法</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" style="text-align:center">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <span id="busuanzi_container_site_pv">Total <span id="busuanzi_value_site_pv"></span> views,</span>
  <span id="busuanzi_container_page_pv">this page <span id="busuanzi_value_page_pv"></span> hits.</span>
  <br/>
  
  &copy;
   2016
   - 
  
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love"><i class="fa fa-heart"></i></span>
  <span class="author" itemprop="copyrightHolder"><a href="mailto:beiping96@gmail.com">duxingrui</a></span>

  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-98210842-1', 'auto');
  ga('send', 'pageview');
  </script>

</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'http-blog-beiping96-com';
      var disqus_identifier = '2016/12/16/EffectiveGo-4-方法、接口和其它类型/';
      var disqus_title = "EffectiveGo-4-方法、接口和其它类型";
      var disqus_url = 'http://blog.beiping96.com/2016/12/16/EffectiveGo-4-%E6%96%B9%E6%B3%95%E3%80%81%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E5%AE%83%E7%B1%BB%E5%9E%8B/';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
        var disqus_config = function () {
            this.page.url = disqus_url;
            this.page.identifier = disqus_identifier;
            this.page.title = disqus_title;
        };
        run_disqus_script('embed.js');
      
    </script>
  




  
  

  

  

  

  


<!--
  <script type="text/javascript" color="0,0,0" opacity='0.33' zIndex="-1" count="66" src="/js/src/canvas-nest.min.js"></script>
-->

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/Epsilon2.1.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>
